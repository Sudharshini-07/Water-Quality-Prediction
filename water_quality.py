# -*- coding: utf-8 -*-
"""Water_Quality.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DQN8fjwk567rH9-Vbmzohjp1hsqaT5ga
"""

import streamlit as st
import pandas as pd
import numpy as np
import time
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, accuracy_score
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
import seaborn as sns
import random
import time


st.set_page_config(page_title="Water Potability Prediction", layout="wide")

st.title("üíß Water Potability Prediction - Real-time Simulated")
st.markdown("Predict whether water is potable (safe to drink) based on its chemical properties.")


@st.cache_data
def load_data():
    df = pd.read_csv("water_potability.csv")
    df.fillna(df.mean(numeric_only=True), inplace=True)
    return df

data = load_data()

def preprocess(df):
    df = df.copy()
    df.fillna(df.mean(numeric_only=True), inplace=True)

    X = df.drop('Potability', axis=1)
    y = df['Potability']

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    return X_scaled, y, scaler

X_scaled, y, scaler = preprocess(data)

X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

@st.cache_resource
def train_model():
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    return model

model = train_model()

st.subheader("üìä Data Distribution and Insights")

col1, col2 = st.columns(2)
with col1:
    st.write("### Sample Data")
    st.dataframe(data.head())

with col2:
    st.write("### Potability Distribution")
    fig1, ax1 = plt.subplots()
    sns.countplot(x='Potability', data=data, ax=ax1)
    ax1.set_xticklabels(['Not Potable', 'Potable'])
    st.pyplot(fig1)

    st.write("---")
    st.write("### üîÑ More Visual Insights")

    
    visualizations = [
        ("Distribution of pH", lambda: sns.histplot(data['ph'], bins=20, kde=True)),
        ("Boxplot of Sulfate", lambda: sns.boxplot(data['Sulfate'])),
        ("Correlation Heatmap", lambda: sns.heatmap(data.corr(), annot=True, cmap='coolwarm')),
    ]

    
    if 'viz_idx' not in st.session_state:
        st.session_state.viz_idx = 0

    title, plot_func = visualizations[st.session_state.viz_idx]

    st.markdown(f"**{title}**")
    fig2, ax2 = plt.subplots()
    plot_func()
    st.pyplot(fig2)

    col_a, col_b = st.columns(2)
    with col_a:
        if st.button("‚¨ÖÔ∏è Previous", key="prev"):
            st.session_state.viz_idx = max(0, st.session_state.viz_idx - 1)

    with col_b:
        if st.button("‚û°Ô∏è Next", key="next"):
            st.session_state.viz_idx = min(len(visualizations) - 1, st.session_state.viz_idx + 1)


st.header("üì• Enter Water Test Parameters:")

with st.form("user_input_form"):
    col1, col2 = st.columns(2)

    with col1:
        ph = st.number_input("pH", min_value=0.0, max_value=14.0, value=7.0)
        Hardness = st.number_input("Hardness (mg/L)", min_value=0.0, value=150.0)
        Solids = st.number_input("Solids (ppm)", min_value=0.0, value=10000.0)
        Chloramines = st.number_input("Chloramines (ppm)", min_value=0.0, value=7.0)
        Sulfate = st.number_input("Sulfate (mg/L)", min_value=0.0, value=330.0)

    with col2:
        Conductivity = st.number_input("Conductivity (ŒºS/cm)", min_value=0.0, value=400.0)
        Organic_carbon = st.number_input("Organic Carbon (ppm)", min_value=0.0, value=10.0)
        Trihalomethanes = st.number_input("Trihalomethanes (Œºg/L)", min_value=0.0, value=66.0)
        Turbidity = st.number_input("Turbidity (NTU)", min_value=0.0, value=3.0)

    submitted = st.form_submit_button("üîç Predict")


if submitted:
    
    input_data = np.array([[ph, Hardness, Solids, Chloramines, Sulfate,
                            Conductivity, Organic_carbon, Trihalomethanes, Turbidity]])

    input_scaled = scaler.transform(input_data)
    prediction = model.predict(input_scaled)[0]
    probability = model.predict_proba(input_scaled)[0][prediction]

    st.subheader("üß† Model Prediction")
    if prediction == 1:
        st.success(f"‚úÖ Water is **Potable** with {probability*100:.2f}% confidence.")
    else:
        st.error(f"‚ùå Water is **Not Potable** with {probability*100:.2f}% confidence.")


with st.expander("üìà Model Accuracy (on test data)"):
    y_pred = model.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    st.metric("Accuracy", f"{acc*100:.2f}%")
    st.text("Classification Report:")
    st.code(classification_report(y_test, y_pred, target_names=["Not Potable", "Potable"]))

def get_next_sample(data):
    idx = random.randint(0, len(data) - 1)
    sample_row = data.drop("Potability", axis=1).iloc[idx]
    true_label = data["Potability"].iloc[idx]
    return sample_row, true_label


if st.button("Fetch Next Data Row (Simulated API Call)"):
    row, true_label = get_next_sample(data)

    if row is not None:
        row_scaled = scaler.transform([row])
        pred = model.predict(row_scaled)[0]
        prob = model.predict_proba(row_scaled)[0][pred]

        st.write("### üîç Incoming Data Sample")
        st.json(row.to_dict())

        st.write("### üß† Model Prediction")
        st.success(f"Predicted: {'Potable' if pred==1 else 'Not Potable'} ({prob*100:.2f}% confidence)")
        st.info(f"Actual Label: {'Potable' if true_label==1 else 'Not Potable'}")

st.subheader("üìà Model Evaluation on Test Set")

if st.checkbox("Show Performance Metrics"):
    y_pred = model.predict(X_test)
    st.code(classification_report(y_test, y_pred, target_names=["Not Potable", "Potable"]))
    st.metric("Accuracy", f"{accuracy_score(y_test, y_pred) * 100:.2f}%")

